import type { Command } from 'commander';
import { resolve } from 'node:path';
import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'node:fs';
import { randomBytes } from 'node:crypto';
import { APP_NAME } from '@forgeai/shared';

// Dynamic imports for ESM-only packages
async function loadChalk() {
  const m = await import('chalk');
  return m.default;
}

async function loadOra() {
  const m = await import('ora');
  return m.default;
}

async function loadInquirer() {
  const m = await import('inquirer');
  return m.default;
}

export function registerOnboardCommand(program: Command): void {
  program
    .command('onboard')
    .description(`Interactive setup wizard for ${APP_NAME}`)
    .action(async () => {
      const chalk = await loadChalk();
      const ora = await loadOra();
      const inquirer = await loadInquirer();

      const forgeDir = resolve(process.cwd(), '.forgeai');
      const envPath = resolve(process.cwd(), '.env');
      const workspacePath = resolve(forgeDir, 'workspace');

      // â”€â”€â”€ Banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      console.log('');
      console.log(chalk.hex('#FF6B35').bold('  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
      console.log(chalk.hex('#FF6B35').bold('  â•‘') + chalk.white.bold(`   ğŸ”¥ ${APP_NAME} â€” Setup Wizard       `) + chalk.hex('#FF6B35').bold('â•‘'));
      console.log(chalk.hex('#FF6B35').bold('  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
      console.log('');
      console.log(chalk.gray('  Este wizard vai configurar o ForgeAI passo a passo.'));
      console.log(chalk.gray('  VocÃª pode executar novamente a qualquer momento com: ') + chalk.cyan('forge onboard'));
      console.log('');

      // â”€â”€â”€ Step 1: Check .env â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      let envContent = '';
      let envExists = existsSync(envPath);
      if (envExists) {
        envContent = readFileSync(envPath, 'utf-8');
      }

      const hasJwtSecret = envContent.includes('JWT_SECRET=') && !envContent.includes('JWT_SECRET=change-me');
      const hasVaultPassword = envContent.includes('VAULT_MASTER_PASSWORD=') && !envContent.includes('VAULT_MASTER_PASSWORD=change-me');

      if (!hasJwtSecret || !hasVaultPassword) {
        console.log(chalk.yellow.bold('  âš¡ Passo 1: SeguranÃ§a'));
        console.log(chalk.gray('  Gerando chaves de seguranÃ§a automaticamente...\n'));

        const jwtSecret = randomBytes(32).toString('hex');
        const vaultPassword = randomBytes(24).toString('base64url');

        const securityLines: string[] = [];
        if (!hasJwtSecret) securityLines.push(`JWT_SECRET=${jwtSecret}`);
        if (!hasVaultPassword) securityLines.push(`VAULT_MASTER_PASSWORD=${vaultPassword}`);

        if (envExists) {
          // Replace existing lines or append
          let updated = envContent;
          if (!hasJwtSecret) {
            if (updated.includes('JWT_SECRET=')) {
              updated = updated.replace(/JWT_SECRET=.*/, `JWT_SECRET=${jwtSecret}`);
            } else {
              updated += `\nJWT_SECRET=${jwtSecret}`;
            }
          }
          if (!hasVaultPassword) {
            if (updated.includes('VAULT_MASTER_PASSWORD=')) {
              updated = updated.replace(/VAULT_MASTER_PASSWORD=.*/, `VAULT_MASTER_PASSWORD=${vaultPassword}`);
            } else {
              updated += `\nVAULT_MASTER_PASSWORD=${vaultPassword}`;
            }
          }
          writeFileSync(envPath, updated, 'utf-8');
        } else {
          const template = [
            '# ForgeAI Gateway Configuration',
            '# Generated by forge onboard',
            '',
            '# Security (auto-generated, do NOT share)',
            `JWT_SECRET=${jwtSecret}`,
            `VAULT_MASTER_PASSWORD=${vaultPassword}`,
            '',
            '# Gateway',
            'GATEWAY_HOST=127.0.0.1',
            'GATEWAY_PORT=18800',
            '',
            '# Database',
            'DB_HOST=127.0.0.1',
            'DB_PORT=3306',
            'DB_USER=root',
            'DB_PASSWORD=',
            'DB_NAME=forgeai',
            '',
          ].join('\n');
          writeFileSync(envPath, template, 'utf-8');
        }

        console.log(chalk.green('  âœ“ JWT_SECRET gerado'));
        console.log(chalk.green('  âœ“ VAULT_MASTER_PASSWORD gerado'));
        console.log(chalk.gray(`  Salvo em: ${envPath}\n`));
      } else {
        console.log(chalk.green.bold('  âœ“ Passo 1: SeguranÃ§a') + chalk.gray(' â€” chaves jÃ¡ configuradas\n'));
      }

      // â”€â”€â”€ Step 2: LLM Provider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      console.log(chalk.yellow.bold('  âš¡ Passo 2: Provedor de IA'));
      console.log(chalk.gray('  Escolha qual LLM provider usar como principal.\n'));

      const providerAnswer = await inquirer.prompt([
        {
          type: 'list',
          name: 'provider',
          message: 'Provedor de IA principal:',
          choices: [
            { name: 'ğŸŸ£ Anthropic (Claude) â€” recomendado', value: 'anthropic' },
            { name: 'ğŸŸ¢ OpenAI (GPT-4o)', value: 'openai' },
            { name: 'ğŸ”µ Google (Gemini)', value: 'google' },
            { name: 'ğŸŒ™ Moonshot (Kimi K2.5)', value: 'moonshot' },
            { name: 'ğŸ”· DeepSeek', value: 'deepseek' },
            { name: 'âš¡ Groq (Llama)', value: 'groq' },
            { name: 'ğŸŸ  Mistral', value: 'mistral' },
            { name: 'âœ–ï¸ xAI (Grok)', value: 'xai' },
            { name: 'â© Pular (configurar depois na Dashboard)', value: 'skip' },
          ],
        },
      ]);

      let apiKeyForProvider = '';
      if (providerAnswer.provider !== 'skip') {
        const providerNames: Record<string, string> = {
          anthropic: 'Anthropic',
          openai: 'OpenAI',
          google: 'Google AI Studio',
          moonshot: 'Moonshot',
          deepseek: 'DeepSeek',
          groq: 'Groq',
          mistral: 'Mistral',
          xai: 'xAI',
        };
        const providerUrls: Record<string, string> = {
          anthropic: 'https://console.anthropic.com/settings/keys',
          openai: 'https://platform.openai.com/api-keys',
          google: 'https://aistudio.google.com/apikey',
          moonshot: 'https://platform.moonshot.cn/console/api-keys',
          deepseek: 'https://platform.deepseek.com/api_keys',
          groq: 'https://console.groq.com/keys',
          mistral: 'https://console.mistral.ai/api-keys',
          xai: 'https://console.x.ai/',
        };

        const pName = providerNames[providerAnswer.provider] ?? providerAnswer.provider;
        const pUrl = providerUrls[providerAnswer.provider] ?? '';

        console.log(chalk.gray(`\n  Obtenha sua API key em: ${chalk.cyan(pUrl)}\n`));

        const keyAnswer = await inquirer.prompt([
          {
            type: 'password',
            name: 'apiKey',
            message: `API Key do ${pName}:`,
            mask: '*',
            validate: (input: string) => input.length > 5 ? true : 'API key parece muito curta',
          },
        ]);

        apiKeyForProvider = keyAnswer.apiKey;
        console.log(chalk.green(`\n  âœ“ API Key do ${pName} salva`));
        console.log(chalk.gray('  A key serÃ¡ armazenada no Vault criptografado ao iniciar o gateway.\n'));
      } else {
        console.log(chalk.gray('\n  VocÃª pode configurar providers depois em: ') + chalk.cyan('http://localhost:18800/settings\n'));
      }

      // â”€â”€â”€ Step 3: Channels â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      console.log(chalk.yellow.bold('  âš¡ Passo 3: Canais de comunicaÃ§Ã£o'));
      console.log(chalk.gray('  Escolha quais canais ativar agora.\n'));

      const channelAnswer = await inquirer.prompt([
        {
          type: 'checkbox',
          name: 'channels',
          message: 'Canais para ativar:',
          choices: [
            { name: 'ğŸ“± Telegram', value: 'telegram' },
            { name: 'ğŸ’¬ WhatsApp', value: 'whatsapp' },
            { name: 'ğŸ® Discord', value: 'discord' },
            { name: 'ğŸ’¼ Slack', value: 'slack' },
            { name: 'ğŸ¢ Microsoft Teams', value: 'teams' },
            { name: 'ğŸŒ WebChat (sempre ativo)', value: 'webchat', checked: true, disabled: 'incluso' },
          ],
        },
      ]);

      const selectedChannels: string[] = channelAnswer.channels;
      const channelTokens: Record<string, string> = {};

      if (selectedChannels.includes('telegram')) {
        console.log(chalk.gray('\n  Crie um bot com @BotFather no Telegram e copie o token.\n'));
        const tgAnswer = await inquirer.prompt([
          {
            type: 'password',
            name: 'token',
            message: 'Telegram Bot Token:',
            mask: '*',
            validate: (input: string) => input.includes(':') ? true : 'Token deve ter o formato 123456:ABC...',
          },
        ]);
        channelTokens['TELEGRAM_BOT_TOKEN'] = tgAnswer.token;
      }

      if (selectedChannels.includes('discord')) {
        console.log(chalk.gray('\n  Crie um bot em https://discord.com/developers/applications\n'));
        const dcAnswer = await inquirer.prompt([
          {
            type: 'password',
            name: 'token',
            message: 'Discord Bot Token:',
            mask: '*',
            validate: (input: string) => input.length > 20 ? true : 'Token parece muito curto',
          },
        ]);
        channelTokens['DISCORD_BOT_TOKEN'] = dcAnswer.token;
      }

      if (selectedChannels.includes('whatsapp')) {
        console.log(chalk.green('\n  âœ“ WhatsApp serÃ¡ configurado via QR code ao iniciar o gateway.\n'));
      }

      if (selectedChannels.includes('slack')) {
        console.log(chalk.gray('\n  Configure um Slack App em https://api.slack.com/apps\n'));
        const slackAnswer = await inquirer.prompt([
          {
            type: 'password',
            name: 'botToken',
            message: 'Slack Bot Token (xoxb-...):',
            mask: '*',
          },
          {
            type: 'password',
            name: 'appToken',
            message: 'Slack App Token (xapp-...):',
            mask: '*',
          },
        ]);
        channelTokens['SLACK_BOT_TOKEN'] = slackAnswer.botToken;
        channelTokens['SLACK_APP_TOKEN'] = slackAnswer.appToken;
      }

      if (selectedChannels.includes('teams')) {
        console.log(chalk.gray('\n  Configure um Bot no Azure AD (Bot Framework)\n'));
        const teamsAnswer = await inquirer.prompt([
          {
            type: 'input',
            name: 'appId',
            message: 'Teams App ID:',
          },
          {
            type: 'password',
            name: 'appPassword',
            message: 'Teams App Password:',
            mask: '*',
          },
        ]);
        channelTokens['TEAMS_APP_ID'] = teamsAnswer.appId;
        channelTokens['TEAMS_APP_PASSWORD'] = teamsAnswer.appPassword;
      }

      // Save channel tokens to .env
      if (Object.keys(channelTokens).length > 0) {
        let currentEnv = readFileSync(envPath, 'utf-8');
        const newLines: string[] = [];
        for (const [key, value] of Object.entries(channelTokens)) {
          if (currentEnv.includes(`${key}=`)) {
            currentEnv = currentEnv.replace(new RegExp(`${key}=.*`), `${key}=${value}`);
          } else {
            newLines.push(`${key}=${value}`);
          }
        }
        if (newLines.length > 0) {
          currentEnv += '\n# Channels (configured by forge onboard)\n' + newLines.join('\n') + '\n';
        }
        writeFileSync(envPath, currentEnv, 'utf-8');
        console.log(chalk.green(`\n  âœ“ ${Object.keys(channelTokens).length} token(s) salvo(s) no .env`));
      }

      // â”€â”€â”€ Step 4: Agent Personality â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      console.log(chalk.yellow.bold('\n  âš¡ Passo 4: Personalidade do agente'));
      console.log(chalk.gray('  Configure como o agente deve se comportar.\n'));

      const personalityAnswer = await inquirer.prompt([
        {
          type: 'list',
          name: 'language',
          message: 'Idioma principal do agente:',
          choices: [
            { name: 'ğŸ‡§ğŸ‡· PortuguÃªs (BR)', value: 'pt-BR' },
            { name: 'ğŸ‡ºğŸ‡¸ English', value: 'en' },
            { name: 'ğŸ‡ªğŸ‡¸ EspaÃ±ol', value: 'es' },
            { name: 'ğŸŒ Auto-detect (match user)', value: 'auto' },
          ],
          default: 'auto',
        },
        {
          type: 'input',
          name: 'agentName',
          message: 'Nome do agente:',
          default: 'ForgeAI',
        },
        {
          type: 'editor',
          name: 'persona',
          message: 'DescriÃ§Ã£o da personalidade (abra o editor ou pressione Enter para usar o padrÃ£o):',
          default: '',
        },
      ]);

      // Write workspace prompts if customized
      if (!existsSync(workspacePath)) {
        mkdirSync(workspacePath, { recursive: true });
      }

      const identityPath = resolve(workspacePath, 'IDENTITY.md');
      if (personalityAnswer.agentName !== 'ForgeAI' || personalityAnswer.language !== 'auto') {
        const langLabel: Record<string, string> = { 'pt-BR': 'PortuguÃªs (BR)', 'en': 'English', 'es': 'EspaÃ±ol', 'auto': 'Auto-detect' };
        const identityContent = `# Agent Identity

## Identity
- Name: ${personalityAnswer.agentName}
- Role: Personal AI Assistant
- Language: ${langLabel[personalityAnswer.language] ?? personalityAnswer.language}

## Context
- Running on your personal machine
- Has access to tools: shell, browser, file manager, desktop control
- Can automate tasks, create projects, manage files, and more
`;
        writeFileSync(identityPath, identityContent, 'utf-8');
        console.log(chalk.green(`  âœ“ IDENTITY.md salvo`));
      }

      if (personalityAnswer.persona && personalityAnswer.persona.trim().length > 10) {
        const soulPath = resolve(workspacePath, 'SOUL.md');
        writeFileSync(soulPath, personalityAnswer.persona.trim(), 'utf-8');
        console.log(chalk.green(`  âœ“ SOUL.md salvo`));
      }

      // â”€â”€â”€ Step 5: Provider key â†’ save for startup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      if (apiKeyForProvider && providerAnswer.provider !== 'skip') {
        // Save provider config to a temp file that chat-routes.ts will read on startup
        const providerConfigPath = resolve(forgeDir, 'onboard-provider.json');
        writeFileSync(providerConfigPath, JSON.stringify({
          provider: providerAnswer.provider,
          apiKey: apiKeyForProvider,
        }), 'utf-8');
        console.log(chalk.green(`  âœ“ Provider config salvo (serÃ¡ ativado no primeiro start)`));
      }

      // â”€â”€â”€ Step 6: Database check â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      console.log(chalk.yellow.bold('\n  âš¡ Passo 5: VerificaÃ§Ã£o final'));

      const spinner = ora({ text: 'Verificando MySQL...', color: 'yellow' }).start();

      try {
        const { initDatabase } = await import('@forgeai/core');
        const db = await initDatabase();
        await db.raw('SELECT 1');
        spinner.succeed('MySQL conectado');
        await db.destroy();
      } catch {
        spinner.warn('MySQL nÃ£o disponÃ­vel â€” o gateway funcionarÃ¡ sem persistÃªncia SQL (usando JSON files)');
      }

      // Check .forgeai directory
      if (!existsSync(forgeDir)) {
        mkdirSync(forgeDir, { recursive: true });
      }

      // â”€â”€â”€ Summary â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      console.log('');
      console.log(chalk.hex('#FF6B35').bold('  â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—'));
      console.log(chalk.hex('#FF6B35').bold('  â•‘') + chalk.white.bold('   âœ… Setup completo!                 ') + chalk.hex('#FF6B35').bold('â•‘'));
      console.log(chalk.hex('#FF6B35').bold('  â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•'));
      console.log('');
      console.log(chalk.white('  Resumo:'));
      console.log(chalk.gray('  â”œâ”€ SeguranÃ§a:  ') + chalk.green('JWT + Vault configurados'));
      console.log(chalk.gray('  â”œâ”€ Provider:   ') + (providerAnswer.provider !== 'skip' ? chalk.green(providerAnswer.provider) : chalk.yellow('configurar depois')));
      console.log(chalk.gray('  â”œâ”€ Canais:     ') + chalk.green(selectedChannels.length > 0 ? selectedChannels.join(', ') : 'WebChat (padrÃ£o)'));
      console.log(chalk.gray('  â”œâ”€ Agente:     ') + chalk.green(personalityAnswer.agentName));
      console.log(chalk.gray('  â””â”€ Idioma:     ') + chalk.green(personalityAnswer.language));
      console.log('');
      console.log(chalk.white('  PrÃ³ximos passos:'));
      console.log(chalk.cyan('  1. ') + chalk.gray('Iniciar o gateway:        ') + chalk.cyan.bold('forge start'));
      console.log(chalk.cyan('  2. ') + chalk.gray('Abrir o dashboard:        ') + chalk.cyan.bold('http://localhost:18800'));
      console.log(chalk.cyan('  3. ') + chalk.gray('Verificar saÃºde:          ') + chalk.cyan.bold('forge doctor'));
      console.log(chalk.cyan('  4. ') + chalk.gray('Editar workspace prompts: ') + chalk.cyan.bold('http://localhost:18800/workspace'));
      console.log('');

      process.exit(0);
    });
}
